%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `sigconf')
%%
%% IMPORTANT NOTICE:%%
%% For the copyright see the source file.
%%
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%%
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%%
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% The first command in your LaTeX source must be the \documentclass command.
\documentclass[sigconf,review, anonymous]{acmart}
\acmConference[ISSTA 2023]{ACM SIGSOFT International Symposium on Software Testing and Analysis}{17-21 July, 2023}{Seattle, USA}

\usepackage{code}
\usepackage{graphicx}
\usepackage{balance}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{subfig}
\usepackage{url}
\usepackage{comment}
\usepackage{xcolor}
\usepackage{xspace}


\definecolor{dkgreen}{rgb}{0,0.5,0}
\definecolor{dkred}{rgb}{0.5,0,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}

\lstdefinestyle{javastyle} {
language=Java,
basicstyle=\ttfamily\bfseries\footnotesize,
  morekeywords={virtualinvoke},
  keywordstyle=\color{blue},
  ndkeywordstyle=\color{red},
  commentstyle=\color{dkred},
  stringstyle=\color{dkgreen},
  numbers=left,
  breaklines=true,
  numberstyle=\ttfamily\footnotesize\color{gray},
  stepnumber=1,
  numbersep=10pt,
  backgroundcolor=\color{white},
  tabsize=4,
  showspaces=false,
  showstringspaces=false,
  xleftmargin=.23in
}
\lstset{style=javastyle}

%%% The following is specific to Onward! '21 and the paper
%%% 'Let a Thousand Flowers Bloom: On the Uses of Diversity in Software Testing'
%%% by Alex Groce.
%%%



%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Program Mutation is Randomized Program Transformation: A
  Universal Approach to Mutant Generation}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
%\author{Alex Groce}
%\affiliation{\institution{Northern Arizona University}\country{United States}}


%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.

%% Table shortcuts
\newcommand{\mr}[2]{\multirow{#1}{*}{#2}}
\newcommand{\mc}[3]{\multicolumn{#1}{#2}{#3}}
\newcommand{\um}{\texttt{universalmutator}\xspace}
%% comments
\newcommand{\clg}[1]{\textcolor{blue}{#1}}
\newcommand{\adg}[1]{\textcolor{purple}{#1}}
\newcommand{\kj}[1]{\textcolor{olive}{#1}}

%% numbers
\newcommand{\averageprojvariance}{402}
\newcommand{\averagevariance}{604}
\newcommand{\outliertotalfiles}{26}
\newcommand{\outliertestissues}{12}
\newcommand{\outlierumissues}{7}
\newcommand{\outlierunclear}{7}
\newcommand{\allcorr}{0.7479}
\newcommand{\covcorr}{0.2066}
\newcommand{\allrsquared}{0.573}
\newcommand{\allr}{0.757}
\newcommand{\covrsquared}{0.021}
\newcommand{\covr}{0.145}


\begin{abstract}
While mutation testing has been a topic of academic interest for
decades, it is only recently that ``real-world'' developers, including
industry leaders such as Google and Meta, have adopted mutation
testing.  In this paper we propose a new approach to the development of mutation
testing tools, and in particular the core challenge of
\emph{generating mutants}.  Current practice tends towards two
limited approaches to mutation generation: mutants are either (1)
generated at the bytecode/IR level, and thus neither human readable
nor adaptable to source-level features of languages or projects, or
(2) generated at the source level by language-specific tools that are
hard to write and maintain, and in fact are often abandoned by both
developers and users.  We propose instead that source-level mutation
generation is a special case of \emph{program transformation} in
general, and that adopting this approach allows for a single tool that
can effectively generate source-level mutants for essentially
\emph{any} programming language. Furthermore, by using \emph{parser
  parser combinators} many of the seeming limitations of an
any-language approach can be overcome, without the need to parse
specific languages.
\end{abstract}


\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10011007.10010940.10010992.10010998.10011001</concept_id>
<concept_desc>Software and its engineering~Dynamic analysis</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011074.10011099.10011102.10011103</concept_id>
<concept_desc>Software and its engineering~Software testing and debugging</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Software and its engineering~Dynamic analysis}
\ccsdesc[500]{Software and its engineering~Software testing and debugging}

\maketitle

\section{Introduction}

\section{Related Work}

There is a large body of work studying mutation testing and its relationship 
with defects, and an extensive literature on test adequacy measured by
code coverage that dates almost to the beginnings of software
engineering; however, we are
unaware of work analyzing the relationship
between mutation score and coverage in terms similar to ours.   While
there is foundational work on the oracle/test
distinction~\cite{StaatsOracle} at a theoretical level, most work assumes a basic framework of  trying to determine
correlation of mutation testing or coverage alone with fault
detection and/or coverage with mutation score~\cite{papadakis2018mutation,PapadakisStudy,ThierryStudy}.  In
such work, the oracle/test distinction is not considered in the
light of whether code is ``more executed'' or ``more checked'' in a
test effort.  Perhaps the
closest approach, which does not involve mutants at all, is the notion
of \emph{checked coverage}~\cite{ZellerCheckedCov}, which, however, still results in a
single score, as does pseudotesting~\cite{pseudotestingorig,
  pseudotestingstudy, descartes}.  Further, checked coverage is
inherently unable to identify buggy assertions that do not in practice
detect mutants, if there is any dynamic flow
from coverage to the faulty assertion.
%\textbf{Relevant Mutation Testing Studies}

%Petrovic et al. \cite{PetrovicTestingPractices} study the relationship between
%mutants and faults, while describing how developers
%have been using mutation testing at Google. They find that mutation testing has a 70\% coupling with high priority
%defects. This helps support our assertion that higher mutation scores are strongly correlated with higher quality oracles, with
%mutation testing being a viable method of catching defects before they occur. Combining the results of with our study regarding the
%oracle gap provides information for practitioners about both the value of mutation testing and when they should be running mutation testing on their code base. 

\begin{comment}
Delgado-PÃ©rez et al. \cite{DelgadoPerezCaseStudy} also performed mutation testing on 2,509 mutants over 15 functions. Their study 
primarily focused on analyzing equivalent mutants and the computational cost of finding these mutants.
They agree with the hypothesis that mutation testing is a better predictor of faults than a
traditional coverage based approach. This large scale study of mutation is similar to our Java study of a large number of
mutants, however the analysis and results differ in that they were analyzing equivalent mutants, while we are examining the
correlation between mutation score and coverage through the lens of the oracle gap. Additionally, our study is over a much 
larger sample size, with over 30 Java projects, that total have 463,417 lines of code, making it more appropriate for extrapolating
generalizable correlations.
\end{comment}

Just et al. \cite{JustMutationFault} found that 73\% of real-world faults can be associated with common mutation
operators. Beller et al. \cite{BellerFacebookMutation} examined how to feasibly
implement mutation testing at Facebook. These studies support the notion that
lagging mutation score indicates lagging fault \emph{detection}
capability even in the presence of coverage, as also suggested by work
by Sina et al. on whether automatically generated unit tests help find bugs~\cite{DoGenerated}.
Smith et al. \cite{SmithCoverageMutation} briefly discussed the
relationship between coverage and mutation score, but 
examined only two open source projects. Li et al. \cite{LiCoverageMutation} also examined when it is best to use various testing methods, including mutation testing. Rather than suggesting
that developers should \emph{either} use mutation score or coverage, we suggest that they should use both metrics, as they
complement each other.  Recent industrial uses of
mutants~\cite{PetrovicMutationGoogle,BellerFacebookMutation} do not
include gap analysis, but informally hint that large-scale users may
be amenable to the type of analysis we provide, given how they use
mutants to pinpoint test issues now.  Finally, it is interesting to consider that
large positive covered oracle gap can be alternatively thought of as
the presence of many \emph{stubborn} mutants in a file~\cite{papadakis2018mutant}.


\section{Conclusion and Implications}

\bibliographystyle{ACM-Reference-Format}
\bibliography{bibliography}


\end{document}
